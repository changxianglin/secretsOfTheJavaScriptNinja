/*
* 第 5 章 精通函数: 闭包和作用域
* 使用闭包可以减少代码数量和复杂度来添加高级特性，还能实现不太可能完成的功能。
* 如果没有闭包，将完全不可能实现私有变量。
* JavaScript 语言的蓝图，以及我们编码的方式，都是由闭包塑造出来的。
* 从传统意义上来说，闭包是由纯函数式编程语言的特性之一。
* 令人鼓舞的是，闭包也进入了主流开发语言，因为闭包能够大大的简化复杂操作，所以很容易在
* JavaScript 库或其他高级代码库种看出闭包的使用。
*
* 闭包带来的问题是 JavaScript 的作用域是如何工作的。为此我们将探讨 JavaScript 的作用域
* 规则，需要特别注意新增的特性。
*
* 5.1 理解闭包
* 闭包允许函数访问并操作函数外部的变量。只要变量或函数存在于声明函数时的作用域内，闭包即可使函数能访问这些
* 变量或函数。
*
* 当在外部函数种声明内部函数时，不仅定义了函数的声明，而且还创建了一个闭包。该闭包不仅包含了函数的声明，
* 还包含了在函数声明作用域中的所有变量。当最终执行内部函数时，尽管声明时的作用域已经消失了，但是通过闭包，
* 任然能够访问到原始作用域。
*
* 谨记每一个通过闭包访问变量的函数都具有一个作用域链，作用域链包含闭包的全部信息，这一点非常重要。
*
* 5.2 使用闭包
* 首先我们会关闭闭包的实用性和优势。
*
* 5.2.1 封装私有变量
* 许多编程语言使用私有变量、这些私有变量时对外部隐藏的对象属性。
* 这是非常有用的一种特性，因为当通过其他代码访问这些变量时，我们不希望
* 对象的实现细节对用户造成过度负荷。
*
* 我们可通过闭包内部方法获取私有变量的值，但是不能直接访问私有变量。这有效地阻止了读取私有变量不
* 可控的修改，这与真是的面向对象语言中的私有变量一样。
*
* 5.2.2 回调函数
* 处理回调函数时另一种常见的使用闭包的情景。
* 闭包内的函数不仅可以在创建时刻访问这些变量，而且当闭包内部的函数执行时，还可以更新这些变量的值。
* 闭包不是在创建的那一时刻的状态的快照，二十一个真是的状态封装，只要闭包在，就可以对变量进行修改。
* 闭包和作用域是强相关的。
*
* 5.2.3 通过执行上下文来跟踪代码
* JavaScript 代码有两种类型：一种是全局代码，在所有函数外部定义，一种是函数代码，位于函数内部。
* JavaScript 引擎执行代码时，每一条语句都处于特定的执行上下文中。
*
* 既然有两种类型的两码，那么就有两种执行上下文：全局执行上下文和函数执行上下文。
* 二者最重要的而差别是：全局执行上下文只有一个，当 JavaScript 程序开始执行时就已经创建了全局上下文，
* 而函数上下文是在每次调用函数时，就会创建一个新的。
*
* 调用栈
*
* 5.4 使用词法环境跟踪变量的作用域
* 词法环境是 JavaScript 引擎内部用来跟踪标识与特定变量质检的映射关系。
*
* 5.4.1 代码嵌套
* 词法环境主要基于代码嵌套，通过代码嵌套可以实现代码结构包含另一代码结构。
*
* 5.4.2 代码嵌套与词法环境
* 除了跟踪局部变量、函数声明、函数的参数和词法环境外,还有必要跟踪外部词法环境。
* 因为我们需要访问外部代码结构中的变量，如果在当前环境无法找到某一标识符。就会对外部环境进行查找。
* 一旦查找到匹配的变量，或是在全局环境中任然无法查找到对应的标识符而返回错误， 就会停止查找。
*
* 无论何时调用函数，都会创建一个新的执行环境，被推入执行上下文栈。
* 此外，还会创建一个与之相关的词法环境。现在来看最重要而部分，外部环境与新建的词法环境。
* JavaScript 引擎将调用函数的内置 【Environment】属性与创建函数时的环境进行关联。
*
* 5.5 理解 JavaScript 的变量类型
* 在 JavaScript 中， 我们可以通过 3 个关键字定义变量： var、let 和 const。
* 这 3 个关键字有两点不同： 可变行=性，与词法环境关系。
*
* 5.5.1 变量可变性
* 如果通过变量而可变性来进行分类，那么可以将 const 放在一组, var 和 let 放在一组。
* 通过 const 定义的变量不可变，也就是说通过 const 声明的变量的值只能设置一次。
* 通过 var 或 let 声明的变量的值可以变更任意次数。
*
* 我们不能将一个全新的值赋值给 const 变量，但是，我们可以修改 const 变量嗯已有的对象。
* const 变量只能声明时被初始化一次，之后再也不允许将全新的值赋值给 const 变量即可。
* 但是，我们任然可以修改 const 变量已经存在的值，只是不能重写 const 变量。
*
* 5.5.2 定义变量的关键字与词法环境
* 定义变量的三个关键字 var、let 与 const , 还可以通过与词法环境的关系进行分类；
* 可将 var 分为一组，let 与 const 分为一组。
*
* 使用关键字 var
* 当使用关键字 var 时，该变量是在距离最近的函数内部或是在全局词法环境中定义的。
*
* 使用 let 与 const 定义具有块级作用域的变量
* var 是在距离最近的函数或全局词法环境中定义变量，与 var 不同的是，let 和 const 更加直接。
* let 和 const 直接在最近的词法环境中定义变量(可以是在块级作用域内、循环内、函数内或全局环境内),
* 我们可以使用 let 和 const 定义块级别、函数级别、全局级别的变量。
*
* 此时我们任然看到 3 个词法环境： 全局环境(函数和块级作用域之外的全局代码)
*
* 在词法环境中注册标识符
* JavaScript 作为一门编程语言，其设计的基本原则是易用性。
* 这也是不需要指定函数返回值类型、函数参数类型、变量类型等的主要原因。
*
* 注册标识符的过程
* 但除了易用性，代码如何逐行执行，JavaScript 引擎是如何知道函数存在呢？
* 这说明 JavaScript 引擎耍了小把戏，JavaScript 代码的执行事实上是分两个阶段进行的。
* 一旦创建了新的词法环境，就会执行第一阶段。在第一阶段，没有执行代码，但是 JavaScript 引擎会访问并注册
* 在当前词法环境中声明的变量和函数。 JavaScript 在第一阶段完成之后开始执行第二阶段，具体如何执行取决于
* 变量的类型( let、var、const 和函数声明)以及环境类型(全局类型、函数环境或块级作用域)
*
* 具体的处理过程如下：
* 1. 如果创建一个函数环境，那么创建形参及函数参数的默认值，如果非函数环境，将跳过此步骤。
* 2. 如果是创建全局函数环境，就扫描当前代码进行函数声明，但不会执行函数表达式或箭头函数，对于找到的函数声明，
* 将创建，并绑定到当前环境域函数名相同的标识符上。 若标识符已经存在，那么该标识符的值将被重写。如果是块级
* 作用域，将跳过此步骤。
* 3. 扫描当前代码进行变量声明，在函数或全局环境中，查找所有当前函数以及其他函数之外通过 var 声明的变量。
* 并查找所有通过 let 或 const 定义的变量。在块级环境中， 仅查找当前块中通过 let 或 const 定义的变量。
* 对于所查看的变量，若该标识已经存在，将保留其值。
*
* 在函数声明之前调用函数
* JavaScript 易用性的一个典型特性，是函数的声明顺序无关紧要。
* JavaScript 引擎通过这种方式为开发者提供便利，允许我们直接使用函数的引用，
* 而不需要强制指定函数的定义循序。在代码执行之前，函数已经存在了。
* 需要注意的是，这种情况仅针对函数声明有效，函数表达式在与箭头函数都不在此
* 列过程中，而是在程序执行过程中执行定义的。
*
*
* 函数重载
*
* 5.6 闭包的工作原理
* 闭包可以访问创建数据时所在作用域内的全部变量。
* 闭包的几种用法
* 通过闭包模拟私有变量，
* 通过闭包使得代码更加优雅
* 闭包与作用域密切相关，闭包对 JavaScript 的作用域规则产生直接影响。
*
*
* 5.6.1 回顾使用闭包模拟私有变量的代码
* 通过闭包课程模拟私有变量。
* 通过关键字 new 调用 JavaScript 构造函数，因此，每次调用构造函数时，
* 都会创建一个新的词法环境，该词法环境保持构造函数内部的局部变量。
* 因此，无论何时创建函数，都会保持词法环境的引用。
* "私有"变量并不是对象的私有属性，但是可以通过构造函数所创建的对象方法去
* 访问这些变量，让我们看看这种方式产生的副作用。
*
* 5.6.2 私有变量而警告
* JavaScript 从未阻止我们将一个对象中创建的属性复制给另一个对象。
* 虽然不是真正的私有变量，但是许多开发者发现这是一种隐藏信息的有用方式。
*
* 5.6.3 回顾闭包和回调函数的例子
* 
* */